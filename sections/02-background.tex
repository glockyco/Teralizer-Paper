\section{Background}
\label{sec:background}

Unit testing is the dominant practice for validating software behavior.
However, conventional tests typically validate only specific input-output pairs
rather than the general properties they represent.
Empirical studies report that regression test suites frequently miss faults
due to incomplete oracles and limited input exploration~\cite{rothermel_1996_analyzing,barr_2015_oracle}.
Each test encodes valuable domain knowledge about expected behavior,
but this knowledge remains underutilized when confined to single examples.
This section establishes the technical foundation for automated test generalization:
test amplification provides the conceptual framework for enhancing existing tests,
property-based testing defines our target representation,
single-path symbolic analysis enables extraction of path-exact specifications from existing test executions,
and mutation testing measures the effectiveness of our generalization approach.

\subsection{Test Amplification}
\label{sec:test-amplification}

Test amplification encompasses techniques that systematically enhance existing test suites
to improve their effectiveness while preserving embedded domain knowledge.
These techniques exploit information already encoded in tests---such as
valid input ranges, expected behaviors, and important scenarios---to
strengthen fault detection without requiring developers to write tests from scratch.
Understanding the different amplification strategies helps clarify
what distinguishes test generalization from other enhancement approaches.
Danglot et~al.~\cite{danglot_2019_snowballing} provide a taxonomy of amplification strategies:
AMP\textsubscript{add} creates new tests from existing ones,
AMP\textsubscript{change} generates tests targeting specific program modifications,
AMP\textsubscript{exec} varies execution conditions,
and AMP\textsubscript{mod} modifies test structure or assertions to generalize behavior.

Test generalization belongs to the AMP\textsubscript{mod} category,
transforming tests from validating individual input-output pairs
to validating properties across entire input partitions.
A test verifying that \texttt{abs(0)} returns \texttt{0}
suggests the general property that \texttt{abs(x)} returns \texttt{x} for non-negative inputs,
but validates this relationship for only a single value.
This single-point validation leaves the test vulnerable to mutations
that preserve behavior at that specific input but break the general property.
Transforming such tests to validate the general property
requires extracting path-exact specifications
that capture program behavior across input partitions
while preserving the validated oracles
that developers have already encoded in their assertions.

\subsection{Property-Based Testing}
\label{sec:property-based-testing}

Property-based testing, pioneered by QuickCheck for Haskell~\cite{claessen_2000_quickcheck}
and now available through frameworks like ScalaCheck for Scala~\cite{nilsson_2014_scalacheck},
Hypothesis for Python~\cite{maciver_2019_hypothesis}, and \ToolJqwik{} for Java~\cite{link_2022_jqwik},
provides the framework for expressing and validating
generalized specifications across entire input partitions.
Instead of verifying that \texttt{abs(0)} returns \texttt{0},
a property-based test would verify that \texttt{abs(x)} returns \texttt{x}
for hundreds of semi-randomly generated non-negative values (typically 100--1,000 iterations).
Property-based testing frameworks provide three key components:
\emph{generators} that produce inputs according to specified constraints,
\emph{properties} that express invariants holding for all generated inputs,
and \emph{shrinking} algorithms that minimize failing inputs to aid debugging.

This combination of constrained generation and property checking
enables thorough exploration of input spaces,
revealing edge cases and boundary conditions
that developers might not explicitly consider~\cite{hughes_2016_experiences,maciver_2019_hypothesis}.
However, adoption remains limited in practice~\cite{goldstein_2024_pbt_practice}.
Creating effective property-based tests requires identifying appropriate properties,
defining input generators with suitable constraints,
and translating example-based assertions into general specifications---a conceptual shift
that creates significant barriers~\cite{barr_2015_oracle,tillmann_2005_parameterized}.
Automated transformation from conventional unit tests to property-based tests
would preserve the domain knowledge encoded in existing test suites
while enabling validation across much larger input spaces.

\subsection{Symbolic Analysis for Specification Extraction}
\label{sec:symbolic-analysis}

Automating the transformation from conventional tests to property-based specifications
requires extracting two elements from each existing test:
the \emph{path condition} that characterizes inputs following the same execution path,
and the \emph{symbolic output expression} that computes expected results for those inputs.
For the \texttt{abs(0)} test, extraction would yield
the path condition \texttt{x >= 0} and the symbolic output \texttt{x}.
Together, these extracted specifications enable property-based tests that validate behavior
across entire input partitions while preserving the original test's semantics.
The specifications must be correct for their execution path
and precise enough to generate valid test inputs and oracles.

Single-path symbolic analysis provides this capability by following
the concrete execution path of an existing test
while maintaining symbolic representations of variables~\cite{pasareanu_2013_symbolic}.
Unlike full symbolic execution, which faces path explosion when exploring all possible paths~\cite{baldoni_2018_survey,cadar_2013_symbolic},
single-path analysis records conditions only along the test's actual execution path.
The analysis extracts path-exact specifications for the covered path
without the high runtime cost of exploring alternative branches.
Each test requires only a single traversal of its execution path,
avoiding the scalability challenges of comprehensive path exploration.

\subsection{Mutation Testing for Evaluation}
\label{sec:mutation-testing}

Mutation testing provides a systematic approach for evaluating
whether generalized tests improve fault detection effectiveness.
The technique systematically introduces artificial faults---such as
arithmetic operator changes, conditional boundary modifications, and return value alterations---and
measures whether test suites detect them~\cite{jia_2011_analysis}.
The mutation score, representing the percentage of detected mutants,
correlates with real fault detection capability~\cite{just_2014_mutants,papadakis_2019_mutation}.

Generalized property-based tests create additional opportunities to detect behavioral deviations
by exploring many inputs within the same execution paths as original tests.
Consider a unit test verifying that \texttt{abs(0)} returns \texttt{0}.
A mutation changing the condition from \texttt{x >= 0} to \texttt{x == 0}
would not be detected by this single test, as the input \texttt{0} still produces the correct result.
However, a generalized property-based test exploring the non-negative partition
would detect that positive values like \texttt{5} incorrectly return \texttt{-5},
immediately revealing the fault.
Tools like \ToolPit{}~\cite{coles_2016_pit} have made mutation testing practical for Java programs,
enabling systematic evaluation of test effectiveness improvements.
