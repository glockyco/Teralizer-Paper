\section{Background}
\label{sec:background}

Unit tests validate specific input-output pairs,
yet often encode broader properties that could be systematically explored.
A test verifying that \texttt{Math.abs(-5)} returns \texttt{5}
suggests the general property that \texttt{Math.abs(x) == -x} for negative inputs,
but only validates this property for a single value.
Automating the extraction and validation of such implicit properties
requires understanding three technical foundations:
how property-based testing frameworks enable systematic input exploration,
what specifications are needed to automate the transformation,
and how single-path symbolic analysis can extract those specifications from existing tests.

\subsection{Property-Based Testing}
\label{sec:property-based-testing}

Property-based testing generalizes from testing specific examples
to testing properties that should hold for entire classes of inputs~\cite{claessen2000quickcheck}.
While a conventional unit test might verify that \texttt{Math.max(3, 5)} returns \texttt{5},
a property-based test would verify that \texttt{Math.max(a, b)} returns the larger value
for hundreds of automatically generated pairs $(a, b)$.
This approach can reveal edge cases and unexpected behaviors
that developers might not think to test explicitly.

Property-based testing frameworks provide two key components:
\emph{generators} (called arbitraries in some frameworks) that produce test inputs
according to specified distributions and constraints,
and \emph{properties} that express invariants that should hold for all generated inputs.
When a property fails, frameworks employ \emph{shrinking} to automatically minimize
the failing input to its simplest form, aiding debugging.

For Java, jqwik~\cite{link2022jqwik} provides comprehensive property-based testing capabilities.
Tests are written as methods annotated with \texttt{@Property} instead of \texttt{@Test},
and input generation is controlled through \texttt{Arbitrary} objects that can encode
complex constraints and distributions.
The framework integrates seamlessly with JUnit 5,
allowing property-based tests to coexist with conventional unit tests
in the same test suite.

Despite its effectiveness at finding bugs,
property-based testing sees limited adoption in practice.
Creating property-based tests requires developers to
(i)~identify properties that should hold across input classes,
(ii)~define appropriate input generators that produce valid test data,
and (iii)~translate existing test assertions into property specifications.
This manual effort, combined with the conceptual shift from examples to properties,
creates a significant barrier to adoption~\cite{barr2015oracle}.

\subsection{Requirements for Automated Generalization}
\label{sec:requirements-for-test-generalization}

Automating the transformation from unit tests to property-based tests
requires extracting specifications that precisely capture
both the input constraints and output computations for each execution path.
Consider a test for \texttt{Math.abs(-5)} that returns \texttt{5}.
To generalize this test, we need to extract:
(1) the exact path condition \texttt{x < 0} that characterizes
which inputs follow the same execution path,
and (2) the symbolic output expression \texttt{-x} that computes
the expected result for any input in that partition.
Together, these specifications enable generation of property-based tests
that verify \texttt{Math.abs(x) == -x} for all \texttt{x < 0}.

These requirements demand specifications that are both
guaranteed correct for the specific execution path
and precise enough to generate valid test inputs and oracles.
Statistical approaches that infer likely invariants cannot provide
the correctness guarantees needed for automated test generation.
Overapproximations used in program verification lose the precision
required for concrete input generation.
Only techniques that can extract exact path conditions
and symbolic output expressions meet these requirements.

\subsection{Single-Path Symbolic Analysis for Specification Extraction}
\label{sec:single-path-symbolic-analysis}

Single-path symbolic analysis provides the precise specification extraction
required for automated test generalization.
This approach leverages symbolic state tracking from concolic execution~\cite{sen2005cute,godefroid2005dart}
but deliberately avoids systematic path exploration.
Concolic execution tools like CUTE and DART combine concrete execution
with symbolic state tracking to systematically explore program paths,
using constraint solving to generate inputs for uncovered branches.
In contrast, single-path symbolic analysis follows only the concrete execution paths
of existing tests while maintaining symbolic representations of variables,
extracting specifications without the computational overhead
of constraint solving for path exploration.

During execution, the analysis treats program variables symbolically
while following the concrete path taken by the test.
At each branch point, it records the condition that was satisfied,
building up a complete path condition without exploring alternative branches.
When the test completes, the analysis has captured both
the path condition (input specification) and the symbolic output expression
that together characterize all inputs leading to the same program behavior.
By focusing on paths already covered by existing tests,
this approach avoids the exponential path explosion
that challenges full symbolic execution~\cite{pasareanu2013symbolic}
while still obtaining the precise specifications needed for test generalization.

The resulting specifications enable automatic transformation
of point-specific unit tests into property-based tests.
Path conditions serve as input constraints for property-based test generators,
while symbolic output expressions provide the expected results for property validation.
This approach systematically explores entire input partitions
while preserving the behavioral assertions of the original tests.
\ToolSPF{} implements single-path symbolic analysis through its constraint collection mode,
which executes tests concretely while tracking symbolic state
to extract precise path conditions and output expressions.