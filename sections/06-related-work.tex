\section{Related Work}
\label{sec:related-work}

Our work draws on ideas from test amplification and symbolic analysis
to automate transformation of conventional unit tests to property-based tests.
This section reviews prior approaches to test generalization
(Section~\ref{sec:rw-generalization}),
discusses research approaches and directions that could
improve specification inference capabilities of our current prototype,
(Section~\ref{sec:rw-inference})
and explores synergies with related techniques as well as adoption considerations
(Section~\ref{sec:rw-synergies}).

\subsection{Test Generalization}
\label{sec:rw-generalization}

Property-based testing~\cite{claessen_2000_quickcheck} and
parameterized unit testing~\cite{tillmann_2005_parameterized}
enable multi-input validation through general properties,
differing primarily in input generation strategy:
property-based tests (PBTs) traditionally use random generation to produce inputs,
whereas \citeauthor{tillmann_2008_pex}
suggest to execute parameterized unit tests (PUTs) symbolically,
utilizing constraint solving to select inputs
for test parameters~\cite{tillmann_2008_pex}.
Both approaches require developers
to manually specify general assertions
that hold across ranges of inputs
rather than specific input-output examples
used in conventional unit tests (CUTs).
\citeauthor{thummalapenta_2011_retrofitting}~\cite{thummalapenta_2011_retrofitting}
demonstrated manual strategies for retrofitting of CUTs to PUTs.

\citeauthor{fraser_2011_generating_put}~\cite{fraser_2011_generating_put}
automated generation of PUTs from CUTs, but use tests without existing assertions
as a starting point.
This sidesteps the problem of automated oracle generalization.
However, it often causes generated PUTs to overfit the implementation~\cite{fraser_2011_generating_put}
because the lack of validated oracles 
makes it difficult to distinguish
intentional behavior from incidental state changes or outputs.
JARVIS~\cite{peleg_2018_jarvis} introduced automated CUT-to-PBT transformation
using black-box analysis with predefined abstraction templates,
which produces overapproximations that require multiple related tests to constrain.
We instead use white-box symbolic analysis along concrete execution paths,
extracting path-exact specifications that generalize oracles
from individual input-output examples.

\subsection{Specification Inference}
\label{sec:rw-inference}

\subsection{Synergies and Adoption}
\label{sec:rw-synergies}
