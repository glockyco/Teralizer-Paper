\subsection{Tested Method Identification}
\label{sec:tested-method-identification}

After identifying generalizable tests and assertions,
the next step in the generalization pipeline
is to identify which implementation methods are validated by the tests.
These methods under test (MUT) serve as targets for subsequent specification extraction.
The challenges encountered in this pipeline stage are twofold.
First, we must distinguish test setup code
from code that exercises and validates the MUT
to be able to restrict specification extraction
to relevant parts of the implementation.
Second, when a test validates multiple MUTs,
we must determine which MUT call corresponds to each assertion
so we can replace the expected value used in the assertion
with the right output specification when creating the corresponding generalized test.
Our current implementation of \ToolTeralizer{} achieves this
through static analysis based on Spoon~\cite{pawlak_2016_spoon}
that traces output values validated by assertions
back to the method calls that produced them.
As a result, \ToolTeralizer{} collects descriptions of
identified MUTs (source code locations, method signatures, etc.)
as well as mappings that connect each MUT call to a corresponding assertion.

Consider the \texttt{testCalculate} method in Listing~\ref{lst:original-test}.
To identify MUT calls in this method,
\ToolTeralizer{} uses Spoon to first get the \texttt{actual}
arguments that are passed into each assertion.
In our example, all three assertions are \texttt{assertEquals} calls with two integer parameters,
matching the method signature \texttt{static void assertEquals(int expected, int actual)}.
\ToolTeralizer{} thus identifies \texttt{b1}, \texttt{b2}, and \texttt{b3}
as the \texttt{actual} arguments of the three assertions.
Since all three arguments are local variables,
\ToolTeralizer{} uses Spoon to identify where they were defined.
For example, for \texttt{b1}, Spoon identifies \texttt{int b1 = c.calculate(2500, 1000)} as the definition.
Since the right side of the assignment is a method call,
\ToolTeralizer{} marks it as a MUT call, storing a description of the method
as well as a mapping to the corresponding \texttt{assertEquals(250, b1)} call in its database.
Processing \texttt{b2} and \texttt{b3} similarly identifies
\texttt{c.calculate(1500, 1000)} and \texttt{c.calculate(500, 1000)}
as the MUT calls for the second and third assertions.

Processing for other assertion types and code structures follows similar patterns.
\ToolTeralizer{} always identifies the assertion argument
that represents the (output of the) MUT call
as its first processing step.
If the argument is a method call,
\ToolTeralizer{} directly marks it as a MUT call.
Otherwise, \ToolTeralizer{} aims to identify
a corresponding method call from the argument.
For example, for local variables,
it traces them back to their definition
using the simple static data flow analysis based on Spoon
we described in the previous paragraph.
For lambda expressions, which are commonly used
as the \texttt{executable} argument of 
\texttt{assertThrows(Class expectedType, Executable executable)}
assertions,
\ToolTeralizer{} instead marks the last method call within the lambda expression as the MUT call,
following the heuristic that the last call typically triggers the expected exception.

Similar to test and assertion filtering,
\ToolTeralizer{} applies three filters to exclude MUTs that
are not viable candidates for generalization:
\texttt{MissingValue}, \texttt{ParameterType}, and \texttt{ReturnType}.
The \texttt{MissingValue} filter rejects cases where
\ToolTeralizer{} cannot identify a MUT for a given assertion
or cannot extract the full method signature for an identified MUT.
Common causes for this include
reversed \texttt{expected} and \texttt{actual} arguments (e.g., \texttt{assertEquals(abs(0), 0)}),
validation of object fields set as side effects rather than return values (e.g., \texttt{assertEquals(3, a.length)}),
and MUTs within inheritance hierarchies that Spoon cannot resolve.
The \texttt{ParameterType} and \texttt{ReturnType} filters reject MUTs
that use unsupported types for all of the MUT's parameters or return values.
While methods with mixed parameter types can be partially generalized
(numeric and boolean parameters become input parameters for property-based tests
while other parameters remain unchanged),
\ToolSPF{} cannot extract complete constraints
for parameters and return values that are strings, arrays, or objects.
This limitation to numeric and boolean types
aligns with current symbolic analysis capabilities
discussed in Section~\ref{sec:symbolic-analysis}.
Section~\ref{sec:limitations-eval} evaluates
how often all filtering-based exclusions occur.
