\subsection{Tested Method Identification}
\label{sec:tested-method-identification}

After identifying generalizable tests and assertions,
the next step is to identify which implementation methods are validated by the tests.
These methods under test (MUT) serve as targets for subsequent specification extraction.
First, we must distinguish test setup code
from code that exercises and validates the MUT
to be able to restrict specification extraction
to relevant parts of the implementation.
Second, when a test validates multiple MUTs,
we must determine which MUT call corresponds to each assertion
so we can replace the expected value used in the assertion
with the right output specification when creating the corresponding generalized test.
\ToolTeralizer{} achieves this
through static analysis based on Spoon~\cite{pawlak_2016_spoon}
that traces output values validated by assertions
back to the method calls that produced them.
% As a result, \ToolTeralizer{} collects descriptions of
% identified MUTs (source code locations, method signatures, etc.)
% as well as mappings that connect each MUT call to a corresponding assertion.

Consider the \texttt{testCalculate} method in Listing~\ref{lst:original-test}.
To identify MUT calls in this method,
\ToolTeralizer{} uses Spoon to first get the \texttt{actual}
arguments that are passed into each assertion.
In our example, all three assertions are \texttt{static void assertEquals(int expected, int actual)} calls.
\ToolTeralizer{} thus identifies \texttt{b1}, \texttt{b2}, and \texttt{b3}
as the \texttt{actual} arguments of the three assertions.
Since all three arguments are local variables,
\ToolTeralizer{} uses Spoon to identify where they were defined.
For example, for \texttt{b1}, Spoon identifies \texttt{int b1 = c.calculate(2500, 1000)} as the definition.
Since the right side of the assignment is a method call,
\ToolTeralizer{} marks it as a MUT call, storing a description of the method
as well as a mapping to the corresponding \texttt{assertEquals(250, b1)} call.
Processing \texttt{b2} and \texttt{b3} similarly identifies
\texttt{c.calculate(1500, 1000)} and \texttt{c.calculate(500, 1000)}
as the MUT calls for the second and third assertions.

Processing for other assertion types and code structures follows similar patterns.
\ToolTeralizer{} first identifies the assertion argument
that represents the (output of the) MUT call.
If the argument is a method call,
\ToolTeralizer{} directly marks it as a MUT call.
Otherwise, \ToolTeralizer{} aims to identify
a MUT call from the argument.
For local variables,
it traces them back to their definition
using the simple data flow analysis based on Spoon
we described in the previous paragraph.
For lambda expressions, which are commonly used
as the \texttt{executable} argument of 
\texttt{assertThrows(Class expectedType, Executable executable)}
assertions,
\ToolTeralizer{} instead marks the last method call within the lambda expression as the MUT call,
following the heuristic that the last call typically triggers the expected exception.

\ToolTeralizer{} applies three filters
to exclude unsuitable MUTs:
\texttt{MissingValue}, \texttt{ParameterType}, and \texttt{ReturnType}.
The \texttt{MissingValue} filter rejects cases where
\ToolTeralizer{} cannot identify a MUT for an assertion
or cannot extract a method signature for an identified MUT.
Common causes for this include
reversed \texttt{expected} and \texttt{actual} arguments (e.g., \texttt{assertEquals(abs(0), 0)}),
validation of object fields set as side effects rather than return values (e.g., \texttt{assertEquals(3, a.length)}),
and MUTs in inheritance hierarchies that Spoon cannot resolve.
The \texttt{ParameterType} and \texttt{ReturnType} filters reject MUTs
that use unsupported types for all of the MUT's parameters or return values.
While methods with mixed parameter types can be partially generalized
(numeric and boolean parameters become test inputs; others remain unchanged),
\ToolSPF{} cannot extract complete constraints
for strings, arrays, and objects.
This is due to symbolic analysis limitations
discussed in Section~\ref{sec:symbolic-analysis}.
Sections~\ref{sec:limitations-eval} and \ref{sec:limitations-eval-extended}
evaluate the exclusion rates of all filters.
