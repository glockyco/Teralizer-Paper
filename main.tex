%%
%% This is file `sample-manuscript.tex',
%% generated with the docstrip utility.
%%
%% The original source files were:
%%
%% samples.dtx  (with options: `all,proceedings,bibtex,manuscript')
%% 
%% IMPORTANT NOTICE:
%% 
%% For the copyright see the source file.
%% 
%% Any modified versions of this file must be renamed
%% with new filenames distinct from sample-manuscript.tex.
%% 
%% For distribution of the original source see the terms
%% for copying and modification in the file samples.dtx.
%% 
%% This generated file may be distributed as long as the
%% original source files, as listed above, are part of the
%% same distribution. (The sources need not necessarily be
%% in the same archive or directory.)
%%
%%
%% Commands for TeXCount
%TC:macro \cite [option:text,text]
%TC:macro \citep [option:text,text]
%TC:macro \citet [option:text,text]
%TC:envir table 0 1
%TC:envir table* 0 1
%TC:envir tabular [ignore] word
%TC:envir displaymath 0 word
%TC:envir math 0 word
%TC:envir comment 0 0
%%
%% The first command in your LaTeX source must be the \documentclass
%% command.
%%
%% For submission and review of your manuscript please change the
%% command to \documentclass[manuscript, screen, review]{acmart}.
%%
%% When submitting camera ready or to TAPS, please change the command
%% to \documentclass[sigconf]{acmart} or whichever template is required
%% for your publication.
%%
%%
\documentclass[manuscript,screen,review]{acmart}
%%
%% \BibTeX command to typeset BibTeX logo in the docs
\AtBeginDocument{%
  \providecommand\BibTeX{{%
    Bib\TeX}}}

%% Rights management information.  This information is sent to you
%% when you complete the rights form.  These commands have SAMPLE
%% values in them; it is your responsibility as an author to replace
%% the commands and values with those provided to you when you
%% complete the rights form.
\setcopyright{acmlicensed}
\copyrightyear{2025}
\acmYear{2025}
\acmDOI{XXXXXXX.XXXXXXX}
%% These commands are for a PROCEEDINGS abstract or paper.
% \acmConference[Conference acronym 'XX]{Make sure to enter the correct
%   conference title from your rights confirmation email}{June 03--05,
%   2018}{Woodstock, NY}
%%
%%  Uncomment \acmBooktitle if the title of the proceedings is different
%%  from ``Proceedings of ...''!
%%
%\acmBooktitle{ACM Transactions on Software Engineering and Methodology}
% \acmISBN{978-1-4503-XXXX-X/2018/06}
\acmJournal{TOSEM}

%%
%% Submission ID.
%% Use this when submitting an article to a sponsored event. You'll
%% receive a unique submission ID from the organizers
%% of the event, and this ID should be used as the parameter to this command.
%%\acmSubmissionID{123-A56-BU3}

%%
%% For managing citations, it is recommended to use bibliography
%% files in BibTeX format.
%%
%% You can then either use BibTeX with the ACM-Reference-Format style,
%% or BibLaTeX with the acmnumeric or acmauthoryear sytles, that include
%% support for advanced citation of software artefact from the
%% biblatex-software package, also separately available on CTAN.
%%
%% Look at the sample-*-biblatex.tex files for templates showcasing
%% the biblatex styles.
%%

%%
%% The majority of ACM publications use numbered citations and
%% references.  The command \citestyle{authoryear} switches to the
%% "author year" style.
%%
%% If you are preparing content for an event
%% sponsored by ACM SIGGRAPH, you must use the "author year" style of
%% citations and references.
%% Uncommenting
%% the next command will enable that style.
%%\citestyle{acmauthoryear}


%%
%% end of the preamble, start of the body of the document source.
\begin{document}

%%
%% The "title" command has an optional parameter,
%% allowing the author to define a "short title" to be used in page headers.
% \title[short title]{full title}
\title{Teralizer: Something About Automated Test Generalization}

%%
%% The "author" command and its associated commands are used to define
%% the authors and their affiliations.
%% Of note is the shared affiliation of the first two authors, and the
%% "authornote" and "authornotemark" commands
%% used to denote shared contribution to the research.
\author{Johann Glock}
\email{johann.glock@aau.at}
\orcid{0000-0002-0152-8611}
\affiliation{%
  \institution{University of Klagenfurt}
  \city{Klagenfurt}
  \country{Austria}
}

\author{Clemens Bauer}
\email{clemens.bauer@aau.at}
\orcid{0009-0000-9199-8563}
\affiliation{%
  \institution{University of Klagenfurt}
  \city{Klagenfurt}
  \country{Austria}
}

\author{Martin Pinzger}
\email{martin.pinzger@aau.at}
\orcid{0000-0002-5536-3859}
\affiliation{%
  \institution{University of Klagenfurt}
  \city{Klagenfurt}
  \country{Austria}
}

%%
%% By default, the full list of authors will be used in the page
%% headers. Often, this list is too long, and will overlap
%% other information printed in the page headers. This command allows
%% the author to define a more concise list
%% of authors' names for this purpose.
\renewcommand{\shortauthors}{Glock et al.}

%%
%% The abstract is a short summary of the work to be presented in the
%% article.
\begin{abstract}
  Abstract
\end{abstract}

%%
%% The code below is generated by the tool at http://dl.acm.org/ccs.cfm.
%% Please copy and paste the code instead of the example below.
%%
\begin{CCSXML}
<ccs2012>
 <concept>
  <concept_id>00000000.0000000.0000000</concept_id>
  <concept_desc>Do Not Use This Code, Generate the Correct Terms for Your Paper</concept_desc>
  <concept_significance>500</concept_significance>
 </concept>
 <concept>
  <concept_id>00000000.00000000.00000000</concept_id>
  <concept_desc>Do Not Use This Code, Generate the Correct Terms for Your Paper</concept_desc>
  <concept_significance>300</concept_significance>
 </concept>
 <concept>
  <concept_id>00000000.00000000.00000000</concept_id>
  <concept_desc>Do Not Use This Code, Generate the Correct Terms for Your Paper</concept_desc>
  <concept_significance>100</concept_significance>
 </concept>
 <concept>
  <concept_id>00000000.00000000.00000000</concept_id>
  <concept_desc>Do Not Use This Code, Generate the Correct Terms for Your Paper</concept_desc>
  <concept_significance>100</concept_significance>
 </concept>
</ccs2012>
\end{CCSXML}

\ccsdesc[500]{Do Not Use This Code~Generate the Correct Terms for Your Paper}
\ccsdesc[300]{Do Not Use This Code~Generate the Correct Terms for Your Paper}
\ccsdesc{Do Not Use This Code~Generate the Correct Terms for Your Paper}
\ccsdesc[100]{Do Not Use This Code~Generate the Correct Terms for Your Paper}

%%
%% Keywords. The author(s) should pick words that accurately describe
%% the work being presented. Separate the keywords with commas.
\keywords{Do, Not, Us, This, Code, Put, the, Correct, Terms, for,
  Your, Paper}

% \received{20 February 2007}
% \received[revised]{12 March 2009}
% \received[accepted]{5 June 2009}

\received{n/a}
\received[revised]{n/a}
\received[accepted]{n/a}

%%
%% A "teaser figure" is an image, or set of images in one figure,
%% that are placed after all author and affiliation information,
%% and before the body of the article, spanning the page. If you
%% wish to have such a figure in your article, place the command
%% immediately before the \maketitle command:
%% \begin{teaserfigure}
%%   \includegraphics[width=\textwidth]{sampleteaser}
%%   \caption{figure caption}
%%   \Description{figure description}
%% \end{teaserfigure}

%%
%% This command processes the author and affiliation and title
%% information and builds the first part of the formatted document.
\maketitle

% ------------------------------------------------------------------------------
% INTRODUCTION
% ------------------------------------------------------------------------------

\section{Introduction}
\label{sec:introduction}

% ------------------------------------------------------------------------------
% BACKGROUND
% ------------------------------------------------------------------------------

\section{Background}
\label{sec:background}

\subsection{Property-based Testing}
\subsection{Test Generalization}

% ------------------------------------------------------------------------------
% APPROACH
% ------------------------------------------------------------------------------

\section{Approach}
\label{sec:approach}

\subsection{Specification Extraction}

\subsubsection{Code Instrumentation}
\subsubsection{JPF Execution}

\subsection{Test Transformation}

using jqwik (1.8.5) for property-based testing (\url{https://github.com/jqwik-team/jqwik});
last official release in 2024 (1.9.2);
last commit 2 days ago (checked on: 2005-04-23);
590 GitHub stars;
built for junit 5!;
comprehensive user guide (\url{https://jqwik.net/docs/current/user-guide.html});

competition 1:
junit-quickcheck (\url{https://github.com/pholser/junit-quickcheck});
last official release in 2020 (1.0);
last commit 8 months ago;
590 GitHub stars;
built for junit 4, junit 5 support only via junit-vintage (\url{https://github.com/pholser/junit-quickcheck/issues/189#issuecomment-414706607});
documentation less comprehensive (\url{https://pholser.github.io/junit-quickcheck/site/1.0/index.html});

competition 2:
quicktheories (\url{https://github.com/quicktheories/QuickTheories});
last official release in 2018 (0.25);
last commit 6 years ago;
509 GitHub stars;
built for junit 4;

\subsubsection{"BASELINE" Generalization}

transforms target test into a property-based test;
one test class per generalizable assertion;
(PIT only offers class-level selections / exclusions, so generating classes causes less "collateral damage" for failing generalizations);
uses only the original set of input values via custom arbitrary;

allows us to see how much runtime overhead jqwik introduces even without any generation of input values;

transformation steps:
clone the original test class (all further actions on the cloned class);
delete other test methods in the class (non-test methods need to be preserved because they might be used by the target test);
add a nested class "TestParameters" that can hold values for all generalizable parameters of the tested method (i.e., all parameters of type byte, short, int, long, float, double);
add a nested class "TestParametersSupplier" that can generate "arbitrary" (jqwik term) "TestParameters" instances;
for the BASELINE variant, only one instance of TestParameters is generated by the supplier;
this instance uses the same tested method input values as the original test;
delete all existingTest annotations from the test method (removing @Test is most important, but other annotations are removed as well because they are unlikely to be compatible with @Property);
add jqwik @Property annotation (seed = 0, ShrinkingMode.OFF, EdgeCasesMode.FIRST, tries = 10 / 50 / 200);
add parameter of type "TestParameters \_p\_" with annotation \@ForAll(supplier = TestParametersSupplier) to the test method;
replace tested method arguments with values from TestParameters instance \_p\_ (e.g., foo(a, b, c) -> foo(\_p\_.a, \_p\_.b, \_p\_.c); only for generalizable inputs, the others remain unchanged).
delete other assertions in the test method (unless they have return values that are used in the code, e.g., Exception e = assertThrows(...));
no need to modify assertions (because inputs stay the same, so expected outputs should also stay the same);

the original test method is always preserved in the current implementation;
this would not be necessary for cases where there is only a single assertion in the test method and generalization is successful;
this would also not be necessary for casses where all assertions in a test method are successfully generalized;
statistics on how common these cases are in R1 (or RQ2? or RQ4?).

because most of the test method is copied for each generalized assertion, this creates a lot of duplicate code;
the currently implementation does not optimize for this at all - statistics on test suite size increases in RQ2;
some of this could likely be avoided by putting in more engineering effort, e.g., automatically extracting setup functions that can be reused across all generalizations of a test method;
alternatively, we could add multiple TestParameters parameters (one for each generalized assertion) - but that might not be very maintainable either;

\subsubsection{"NAIVE" Generalization}

same basic processing flow as BASELINE variant (clone class, add TestParameters + Supplier, remove other tests + assertions);
uses "naive" approach for selecting sets of input values;

basic approach:
step 1: randomly generate sets of values that match the types of input parameters;
step 2: apply filter to keep only value sets that satisfy the input specification;
repeat until desired number of input sets (we use 10, 50, 200 in the evaluation) has been generated (automatically done by jqwik, we just set how many we want);
still preserves original test inputs via a custom arbitrary => no reduction of mutation score due to "bad" random values;

problem: many TooManyFilterMissesExceptions;
reason: depending on the input specification, randomly selecting sets of input values can be (very) unlikely to produce satisfying inputs (e.g., a = b = c => 3 random ints that are equal);

example: a = b = c (all ints);
randomly generate a;
randomly generate b;
randomly generate c;
apply the a = b = c filter (likely not a match => throw away and try again; after too many non-matching attempts => TooManyFilterMissesExceptions)

\subsubsection{"IMPROVED" Generalization}

same basic processing flow as BASELINE variant (clone class, add TestParameters + Supplier, remove other tests + assertions);
uses "improved" approach for selecting sets of input values to reduce TooManyFilterMissesExceptions;

basic approach:
step 1: generate sets of input values that already take into account "as many constraints as possible";
step 2: apply filter to keep only value sets that satisfy the full input specification;
repeat until the desired number of input sets has been generated;
like NAIVE, IMPROVED also preserves original test inputs via a custom arbitrary;

example: a = b \&\& b = c (all ints);
randomly generate a since we don't have any constraints to consider yet;
generate b such that b = a (i.e., take into account the a = b constraint);
generate c such that b = c (i.e., take into account the b = c constraint);
apply the a = b = c filter (trivial in this case => use a more interesting example);

currently only considers the following constraints:
var1 == (var2 | const);
var1 < (var2 | const);
var1 <= (var2 | const);
var1 > (var2 | const);
var1 >= (var2 | const);

supported types: byte, short, int, long, float, double;
mixed-type constraints are also supported (e.g., int-var < float-var);

more complex terms (e.g., "compound" terms (is this the correct terminology?), (trigonometric) function calls) are not taken into account (e.g., a < b - c, a == cos(b));
constraints that are not equality, upper- or lower-bound constraints are not taken into account either (e.g., inequality constraints);
=> show some statistics about used vs. unused constraints -> further details in RQ4 or the discussion;

actual value selection logic (code that implements this logic for all generalizable inputs is automatically generated):

if at least one equality constraint exists for a variable, all other constraints are ignored
if multiple equality constraints exist, we just take "the first one";
all equality constraints have the same value anyway because we select these at runtime based on whichever concrete values have already been assigned to involved variables;

if multiple upper / lower bounds exist, the strongest bound is used, i.e., the highest lower bound and the lowest upper bound.
as with equality constraints, this is determined at runtime, i.e., based on on whichever values have already been assigned to involved variables;

in practice, naive processing of constraints often leads to "dead ends" where no further assignments are possible;
for example: a >= b \&\& b >= a; here we would have a ">= b" constraint on "a" and a ">= a" constraint on "b";
to resolve such situations, we assign an index to each variable that occurs in the input specification, e.g., idx(a)=1, idx(b)=2;
constraints are then rewritten to apply only to the variable with the highest index, e.g. (i) "a >= b" -> "b <= a", and (ii) "b >= a" -> "b >= a";
thus, the used constraints for variable value selection become: a -> no constraints, b -> {"<= a", ">= a"};
since a is now unconstrained, we can simply select a random value for it; once a is assined, b can be assigned as well; 
similar transformations are applied for all suppored constraints (==, <, <=, >, >=);
(todo: find the correct terminology to describe this; perhaps constraint rewriting / simplification?
other related terms: constraint satisfaction problems, variable elimination, constraint propagation, domain reduction, and arc consistency algorithms)

in some cases, choices of early variables lead to unsatisfiable constraints later on;
for example: b > a \&\& b <= 0 -> no satisfying assignment for b if a a >= 0;
in this cases, we return an empty arbitrary for b, thus prompting jqwik to pick a new value for a;
similar situations occur for over-/underflows, e.g., b > a with a = Integer.MAX\_VALUE;
in this case, b = a + 1 = Integer.MIN\_VALUE, which will be rejected by filtering;

some current limitations could be resolved through more engineering effort (e.g., custom arbitraries);
one way to generate values that satisfy all / more constraints would be through constraint solving (add references);
however, this would have a significant runtime cost and would still suffer various limitations (add references);

\subsection{Test / Assertion / Generalization Filtering}

describe filtering here or in RQ4?

we need to ensure that:
1: we do not generate any incompilable code;
2: we have a green test suite for mutation testing (PIT only works with green suites - otherwise it throws an error);
also, we would like to avoid spending processing effort on generalization attempts that are unlikely to be successful (=> early excludes);
to achieve this, we apply filtering at multiple stages + levels in the processing pipeline (for filtering data, see RQ4).

(note: large reduction of required filtering would be possible by putting in more engineering effort)

\subsubsection{Test-level Filtering}

filterTestOriginal:
NonPassingTestFilter: filters failing tests (PIT requires green suite, and generalization of failing tests does not seem useful anyway);
TestTypeFilter: filters tests with unsupported test annotations (we currently only support @Test annotations);

filterTest:
NoAssertionsFilter: filters tests without assertions (with no assertions, choosing a target method is even trickier than it already is, and we have no useful output specification);

\subsubsection{Assertion-level Filtering}

filterAssertion:
ExcludedTestFilter: filters assertions that are part of filtered or otherwise excluded tests (if the tests cannot be handled, assertion-level results cannot override this);
MissingValueFilter: filters assertions for which no tested method could be identified (without a tested method, we don't have specifications, so cannot perform generalization);
VoidReturnTypeFilter: filters assertions with a tested method that has a void return type (no return type -> no output specification -> no generalization);
UnsupportedAssertionFilter: filters unsupported assertions (we currently only support assertEquals, assertTrue, assertFalse, and (with some caveats?) asserThrows);
ParameterTypeFilter: filters assertions with a tested method that has no parameters of supported types (we can currently generalize parameters of types byte, short, int, long, float, double);

\subsubsection{Generalization-level Filtering}

filterGeneralization:
NonPassingTestFilter: filters generalizations that fail during test execution (PIT requires green suite, can be either due to "incorrect" generalization or due to "bad" original tests);

\subsubsection{Other Limits / Safeguards}

During SPF execution:
maximum PC size limit;
maximum depth limit;
maximum execution time;

During Test Transformation:
maximum Java specification size;

% ------------------------------------------------------------------------------
% EVALUATION
% ------------------------------------------------------------------------------

\section{Evaluation}
\label{sec:evaluation}

primary effects, ancillary effects, runtime requirements, limitations

\begin{itemize}
  \item RQ1: To which degree does generalization affect the mutation score of the target test suites?
  \item RQ2: To which degree does generalization affect the size and runtime of the target test suites?
  \item RQ3: What are the runtime requirements of the generalization approach?
  \item RQ4: What are the causes of unsuccessful generalization attempts?
\end{itemize}

\subsection{Target Programs}

selection criteria: can be processed by SPF (=> java 8!, numeric inputs + outputs, no randomness), use junit 4 or 5 for testing, use maven or gradle as build system, ...?

\subsubsection{EqBench}

well-suited for processing with SPF, but no test suite available;

tests generated with EvoSuite;
came "third" in SBFT Tool Competition 2025 - Java Test Case Generation Track (https://arxiv.org/pdf/2504.09168), but differences between top 3 not statistically significant per the paper;
can't find a summary paper for SBFT 2024;
performed best on the SBFT Tool Competition 2023 - Java Test Case Generation Track for line and branch coverage metrics, and second-best for understandability metric;
also the overall winner for SBST Tool Competition 2022 and SBST Tool Competition 2021 which use line + branch (via JaCoCo) and mutation coverage (via PIT) as metrics;

3 different test suites with search budgets: 1s, 10s, 60s (= EvoSuite default);
no other changes to default EvoSuite configuration

descriptive statistics (evosuite runtime, number of classes, number of tests, LOC, ...)

\subsubsection{Apache Commons Utils}

manually collected;
utility classes from apache commons projects;
classes identified via SourceGraph (based on SPF limitations);
corresponding test classes manually identified;
modified pom.xml to disable license header requirement, no other changes;
additionally same 3 EvoSuite generated test suites as above

descriptive statistics (evosuite runtime, number of classes, number of tests, LOC, ...)

\subsection{Evaluation Setup}

Hardware: MacBook Air, M2, 24 GB memory

target programs as above

variants:

\begin{itemize}
  \item ORIGINAL: before any processing
  \item INITIAL: after SPF execution
  \item BASELINE: after generalization (only original test inputs)
  \item NAIVE (with 10 / 50 / 200 tries): after generalization (naive input selection)
  \item IMPROVED (with 10 / 50 / 200 tries): after generalization (improved input selection)
\end{itemize}

\subsection{RQ1: Effects on Mutation Score}

using PIT for mutation testing;
most mutation testing tools do not provide results in a structured format that's suitable for automated processing
and / or do not provide (official) support for Java 8, and / or are not actively maintained anymore
(according to the PIT website: \url{https://pitest.org/java_mutation_testing_systems/#summary-of-mutation-testing-systems})

number of mutants per project + mutator (for variant INITIAL?)

number of covered / uncovered mutants per project (for variant INITIAL?)
mention degree of coverage change as a sidenote (no (large) change is by design)

percentage of survived / detected / ... mutants per project + variant (relative to number of covered mutants)

number of newly killed mutants  per project + variant

number / percentage of killing generalizations

differences between killed / unkilled mutants (here or in RQ4?)

\subsection{RQ2: Effects on Test Suite Size and Runtime}

effects on the number of tests in the test suite

effects on the number of lines of code in the test suite

effects on the execution time of individual tests

effects on the total execution time of the test suite

\subsection{RQ3: Runtime Requirements}

only one run for each configuration (due to high runtime requirements)
investigation for a subset of configurations confirmed that the trends hold

total runtime (+ runtime per project?)

runtime per project + processing stage + variant

efficiency relative to higher EvoSuite search budgets

large potential for runtime improvements, see examples in the discussion

\subsection{RQ4: Causes of Unsuccessful Generalizations}

describe filtering here or in RQ4?

overall test / assertion / generalization exclusions

filtering-based test / assertion / generalization exclusions

exclusions caused by JFP execution failures

differences between killed / unkilled mutants (here or in RQ1?)

% ------------------------------------------------------------------------------
% DISCUSSION
% ------------------------------------------------------------------------------

\section{Discussion}
\label{sec:discussion}

\subsection{Benefits of the Approach}

\subsection{Potential for Future Improvements}

\subsubsection{Improving the Mutation Score of Generalized Tests}
\subsubsection{Improving the Size of Generalized Tests}

\subsubsection{Improving the Runtime of Test Generalization}

primary runtime costs are from external tools (i.e., jqwik + PIT)

mutation testing runtimes could likely be improved
through the use of the pitest accelerator plugin (\url{https://docs.arcmutate.com/docs/accelerator.html}),
thus, further improving results of Teralizer relative to EvoSuite
(website claims "analysis time for Commons Lang is reduced from over 55 minutes to under 18");
however, the plugin is not available without a license

also, parallelization would be possible rather easily for many Teralizer tasks
(and also for PIT, which only runs single-threaded by default)
(supposedly, jqwik will get parallelization support in major version 2, source (2024-05-14): \url{https://github.com/jqwik-team/jqwik/issues/45#issuecomment-2109949764})

for practical application scenarios, could add configuration to target only specific tests, rather than the full test suite

\subsubsection{Using Test Generalization for Test Suite Reduction}

\subsection{Threats to Validity}

\subsubsection{Construct Validity}
\subsubsection{Internal Validity}
\subsubsection{External Validity}

% ------------------------------------------------------------------------------
% RELATED WORK
% ------------------------------------------------------------------------------

\section{Related Work}
\label{sec:related-work}

% ------------------------------------------------------------------------------
% CONCLUSIONS
% ------------------------------------------------------------------------------

\section{Conclusions}
\label{sec:conclusions}

%%
%% The acknowledgments section is defined using the "acks" environment
%% (and NOT an unnumbered section). This ensures the proper
%% identification of the section in the article metadata, and the
%% consistent spelling of the heading.
\begin{acks}
This research was funded in whole or in part by the Austrian Science Fund (FWF) 10.55776/P36698. For open access purposes, the author has applied a CC BY public copyright license to any author accepted manuscript version arising from this submission.
\end{acks}

%%
%% The next two lines define the bibliography style to be used, and
%% the bibliography file.
\bibliographystyle{ACM-Reference-Format}
\bibliography{main}

\end{document}
\endinput
%%
%% End of file `sample-manuscript.tex'.
